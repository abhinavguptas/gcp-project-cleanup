#!/usr/bin/env python3
# Copyright 2026 Concret.io
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Delete GCP Projects

This script reads the projects_for_deletion.json file generated by find_obsolete_projects.py
and deletes the projects listed in it.

WARNING: This script will permanently delete GCP projects. Use with caution!
"""

import sys
import json
import subprocess
import time
from pathlib import Path
from typing import List, Dict, Any
from datetime import datetime


class ProjectDeleter:
    """Delete GCP projects based on deletion file."""

    def __init__(self, deletion_file: Path, dry_run: bool = True):
        """
        Initialize the project deleter.

        Args:
            deletion_file: Path to the JSON file with projects to delete
            dry_run: If True, only show what would be deleted without actually deleting
        """
        self.deletion_file = deletion_file
        self.dry_run = dry_run
        self.deleted = []
        self.failed = []
        self.skipped = []
        self._data = None  # Holds loaded data for updates
    
    def _log(self, message: str, level: str = "INFO"):
        """Log a message with timestamp."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] {level}: {message}", flush=True)
    
    def _run_gcloud(self, args: List[str]) -> Dict[str, Any]:
        """Run a gcloud command."""
        command = ['gcloud'] + args
        
        if self.dry_run:
            self._log(f"[DRY RUN] Would execute: {' '.join(command)}", "CMD")
            return {'success': True, 'dry_run': True}
        
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=False
            )
            return {
                'success': result.returncode == 0,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'returncode': result.returncode
            }
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def load_deletion_file(self) -> Dict[str, Any]:
        """Load the deletion file."""
        if not self.deletion_file.exists():
            self._log(f"Deletion file not found: {self.deletion_file}", "ERROR")
            sys.exit(1)

        self._log(f"Loading deletion file: {self.deletion_file}", "INFO")
        try:
            with open(self.deletion_file, 'r') as f:
                self._data = json.load(f)

            # Count already deleted
            already_deleted = sum(
                1 for p in self._data.get('projects_to_delete', [])
                if p.get('deletion_status') == 'deleted'
            )
            already_deleted += sum(
                1 for p in self._data.get('projects_to_review', [])
                if p.get('deletion_status') == 'deleted'
            )

            self._log(f"Loaded deletion file", "SUCCESS")
            self._log(f"  -> {self._data['summary']['total_safe_to_delete']} projects safe to delete", "INFO")
            self._log(f"  -> {self._data['summary']['total_need_review']} projects need review", "INFO")
            if already_deleted > 0:
                self._log(f"  -> {already_deleted} projects already deleted (will skip)", "INFO")
            return self._data
        except Exception as e:
            self._log(f"Error loading deletion file: {e}", "ERROR")
            sys.exit(1)

    def _save_deletion_file(self):
        """Save the updated deletion file with deletion status."""
        if self._data is None:
            return
        try:
            with open(self.deletion_file, 'w') as f:
                json.dump(self._data, f, indent=2, default=str)
        except Exception as e:
            self._log(f"Warning: Could not save deletion file: {e}", "WARN")

    def _mark_project_deleted(self, project_id: str):
        """Mark a project as deleted in the data structure and save."""
        if self._data is None:
            return

        # Find and update in projects_to_delete
        for project in self._data.get('projects_to_delete', []):
            if project.get('project_id') == project_id:
                project['deletion_status'] = 'deleted'
                project['deleted_at'] = datetime.now().isoformat()
                break

        # Find and update in projects_to_review
        for project in self._data.get('projects_to_review', []):
            if project.get('project_id') == project_id:
                project['deletion_status'] = 'deleted'
                project['deleted_at'] = datetime.now().isoformat()
                break

        # Save immediately
        self._save_deletion_file()
    
    def delete_project(self, project: Dict[str, Any], force: bool = False) -> bool:
        """Delete a single project."""
        project_id = project['project_id']
        project_name = project.get('project_name', 'N/A')
        deletion_status = project.get('deletion_status', 'unknown')

        self._log("", "INFO")
        self._log(f"Processing: {project_name} ({project_id})", "INFO")
        self._log(f"  Status: {deletion_status}", "INFO")
        self._log(f"  Resources: {project.get('total_resources', 0)}", "INFO")
        self._log(f"  Reasons: {', '.join(project.get('obsolete_reasons', []))}", "INFO")

        # Skip already deleted projects
        if deletion_status == 'deleted':
            deleted_at = project.get('deleted_at', 'unknown time')
            self._log(f"  [SKIP] Already deleted at {deleted_at}", "INFO")
            self.skipped.append(project)
            return False

        # Only delete projects marked as safe_to_delete, unless force is True
        if deletion_status not in ('safe_to_delete', 'review_required') or \
           (deletion_status == 'review_required' and not force):
            self._log(f"  [SKIP] Status: {deletion_status} (use --force for review_required)", "WARN")
            self.skipped.append(project)
            return False

        # Delete the project
        self._log(f"  Deleting project...", "INFO")
        result = self._run_gcloud(['projects', 'delete', project_id, '--quiet'])

        if result.get('success'):
            if self.dry_run:
                self._log(f"  [DRY RUN] Would delete project successfully", "SUCCESS")
            else:
                self._log(f"  Project deletion initiated", "SUCCESS")
                self._log(f"    Note: Project deletion may take some time to complete", "INFO")
                # Mark as deleted in the file immediately
                self._mark_project_deleted(project_id)
            self.deleted.append(project)
            return True
        else:
            error_msg = result.get('stderr', result.get('error', 'Unknown error'))
            self._log(f"  [FAIL] {error_msg[:200]}", "ERROR")
            self.failed.append({**project, 'error': error_msg})
            return False
    
    def delete_projects(
        self,
        data: Dict[str, Any],
        only_safe: bool = True,
        include_review: bool = False,
        force: bool = False
    ):
        """Delete projects from the deletion file."""
        mode = "DRY RUN" if self.dry_run else "LIVE"
        self._log("", "INFO")
        self._log("=" * 80, "INFO")
        self._log(f"PROJECT DELETION - {mode} MODE", "INFO")
        self._log("=" * 80, "INFO")

        if self.dry_run:
            self._log("DRY RUN MODE: No projects will actually be deleted", "WARN")
        
        projects_to_process = []
        
        # Add projects safe to delete
        if only_safe:
            projects_to_process.extend(data['projects_to_delete'])
            self._log(f"Will process {len(data['projects_to_delete'])} projects marked as safe to delete", "INFO")
        
        # Add projects needing review if requested
        if include_review:
            projects_to_process.extend(data['projects_to_review'])
            self._log(f"Will also process {len(data['projects_to_review'])} projects needing review", "INFO")
        
        if not projects_to_process:
            self._log("No projects to process", "INFO")
            return
        
        # Confirm deletion
        if not self.dry_run:
            self._log("", "INFO")
            self._log(f"WARNING: About to delete {len(projects_to_process)} project(s)", "WARN")
            response = input("Type 'DELETE' to confirm: ")
            if response != 'DELETE':
                self._log("Deletion cancelled", "INFO")
                return
        
        # Delete each project
        for i, project in enumerate(projects_to_process, 1):
            self._log(f"[{i}/{len(projects_to_process)}] Processing project...", "INFO")
            self.delete_project(project, force=force)
            if not self.dry_run:
                time.sleep(1)  # Small delay between deletions
        
        # Summary
        self._log("", "INFO")
        self._log("=" * 80, "INFO")
        self._log("DELETION SUMMARY", "INFO")
        self._log("=" * 80, "INFO")
        action = 'deleted' if not self.dry_run else 'would delete'
        self._log(f"Successfully {action}: {len(self.deleted)}", "SUCCESS")
        self._log(f"Failed: {len(self.failed)}", "ERROR" if self.failed else "INFO")
        self._log(f"Skipped: {len(self.skipped)}", "WARN" if self.skipped else "INFO")

        if self.failed:
            self._log("", "INFO")
            self._log("Failed projects:", "ERROR")
            for project in self.failed:
                self._log(f"  - {project['project_id']}: {project.get('error', 'Unknown error')[:100]}", "ERROR")

        if not self.dry_run and self.deleted:
            self._log("", "INFO")
            self._log(f"Deletion file updated: {self.deletion_file}", "INFO")
            self._log("  Deleted projects marked with deletion_status='deleted'", "INFO")


def main():
    """Main function."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Delete GCP projects based on deletion file',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Dry run (safe, shows what would be deleted)
  python3 delete_projects.py
  
  # Actually delete projects (requires confirmation)
  python3 delete_projects.py --execute
  
  # Delete including projects that need review
  python3 delete_projects.py --execute --include-review
  
  # Force delete projects marked for review
  python3 delete_projects.py --execute --include-review --force
        """
    )
    
    parser.add_argument(
        '--file',
        type=Path,
        default=Path(__file__).parent / 'projects_for_deletion.json',
        help='Path to deletion file (default: projects_for_deletion.json)'
    )
    parser.add_argument(
        '--execute',
        action='store_true',
        help='Actually delete projects (default: dry run)'
    )
    parser.add_argument(
        '--include-review',
        action='store_true',
        help='Also delete projects marked as "review_required"'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force delete projects even if marked as review_required'
    )
    
    args = parser.parse_args()
    
    # Initialize deleter
    deleter = ProjectDeleter(
        deletion_file=args.file,
        dry_run=not args.execute
    )
    
    # Load deletion file
    data = deleter.load_deletion_file()
    
    # Delete projects
    deleter.delete_projects(
        data,
        only_safe=True,
        include_review=args.include_review,
        force=args.force
    )


if __name__ == '__main__':
    main()
